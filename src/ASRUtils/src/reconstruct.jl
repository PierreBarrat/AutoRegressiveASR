"""
    reconstruct(
        folder, model::EvolutionModel, strategy::ASRMethod;
        tree_file, alignment_file, outfiles, prefix
    )

Perform ancestral reconstruction using `folder/tree_file` and `folder/alignment_file`.
Result alignment of internals is written in `folder/prefix/of` for `of` in `outfiles`
(vector, in case of multiple repetitions).
"""
function reconstruct(
    folder, model::ASR.EvolutionModel, strategy::ASR.ASRMethod;
    tree_file = "tree.nwk",
    alignment_file = "alignment_leaves.fasta",
    outfiles = ["reconstructed_$(i).fasta" for i in 1:strategy.repetitions],
    outnewick = "",
    outtable = "",
    prefix = "reconstructed",
    kwargs...
)
    mkpath(joinpath(folder, prefix))

    fasta_files(aln::AbstractString) = joinpath(folder, prefix, aln)
    fasta_files(alignments::AbstractArray) = [fasta_files(aln) for aln in alignments]

    return ASR.infer_ancestral(
        joinpath(folder, tree_file), joinpath(folder, alignment_file), model, strategy;
        outfasta = fasta_files(outfiles),
        outtable = isempty(outtable) ? nothing : joinpath(folder, prefix, outtable),
        outnewick = isempty(outnewick) ? nothing : joinpath(folder, prefix, outnewick),
        kwargs...,
    )
end

"""
    reconstruct_iqtree(folder; tree_file, alignment_file, kwargs...)

Reconstruct using `folder/tree_file` and `folder/alignment_file`.
Note that `iqtree` will recompute the branch lengths of the tree, and potentially change
the position of the root if no outgroup is provided.

# Keyword arguments

- `prefix`: prefix all output files. Can be a directory, *e.g.* `"iqtree/"`
- `iqtree_prefix`: prefix files constructed directly by iqtree. Added at the end of `prefix`
- `outgroup_name`: label of node to root on. Not tested if `""` is passed.
- `out_tree_file`: iqtree recomputes the tree (branch lengths). The new tree is stored here.
- `model`: provide a specific model. If `nothing`, uses iqtree's model finder.
"""
function reconstruct_iqtree(
    folder;
    tree_file = "tree.nwk",
    alignment_file = "alignment_leaves.fasta",
    prefix = "",
    iqtree_prefix = "IQTREE",
    outgroup = false,
    outgroup_name = "",
    out_tree_file = "tree_iqtree.nwk",
    model = nothing,
    root_with_init_tree = true,
    scale_branch_length = false,
)
    tree = joinpath(folder, tree_file)
    aln = joinpath(folder, alignment_file)
    mkpath(joinpath(folder, prefix))
    tot_prefix = joinpath(folder, prefix, iqtree_prefix)

    # reconstruction
    base_cmd = ["iqtree2 -asr -s $aln -te $tree -pre $(tot_prefix) --keep-ident -redo"]
    !isnothing(model) && push!(base_cmd, "  -m $model ")
    outgroup && push!(base_cmd, " -o $(outgroup_name) ")
    if scale_branch_length
        push!(base_cmd, " -blfix -blscale")
    end

    cmd = string.(split(prod(base_cmd))) |> Cmd
    @info "Running iqtree with command $cmd"
    run(cmd)

    if root_with_init_tree
        tree_model = read_tree(tree)
        tree_iq = read_tree(joinpath(folder, prefix, "$(iqtree_prefix).treefile"))
        tree_iq = ASRU.rearrange_from_model(tree_iq, tree_model)
        write(joinpath(folder, prefix, out_tree_file), tree_iq)
    else
        cp(
            joinpath(folder, prefix, "$(iqtree_prefix).treefile"),
            joinpath(folder, prefix, out_tree_file);
            force=true
        )
    end

    # # reconstruction
    # if isnothing(model)
    #     run(`iqtree2 -asr -s $aln -te $tree -pre $(tot_prefix) -o $(outgroup_name) --keep-ident --redo`)
    # else
    #     run(`iqtree2 -asr -s $aln -te $tree -pre $(tot_prefix) -o $(outgroup_name) --keep-ident --redo -m $model`)
    # end


    # copying IQTREE.treefile
    # cp(
    #     joinpath(folder, prefix, "$(iqtree_prefix).treefile"),
    #     joinpath(folder, prefix, out_tree_file);
    #     force=true
    # )

end

"""
    alignment_from_iqtree_state(
        folder;
        repetitions = 1,
        ML = true,
        state_file = "IQTREE.state",
        out_files,
        prefix = "",
        alphabet = :aa,
    )

Parse the `.state` file generated by iqtree, and sample alignments from it.
Output written to `joinpath(prefix, out_files)`.
"""
function alignment_from_iqtree_state(
    folder;
    ML = true,
    state_file = "IQTREE.state",
    out_files = ["reconstructed_internals.fasta"],
    prefix = "",
    alphabet = AA_IQTREE_ALPHABET,
    nodes = nothing,
)
    node_models = parse_iqtree_state_file(joinpath(folder, state_file); alphabet)
    for out_fasta in out_files
        of = joinpath(folder, prefix, out_fasta)
        mkpath(dirname(of))
        FASTA.Writer(open(of, "w")) do writer
            for (name, nm) in node_models
                sequence = if ML
                    nm.ml_seq
                else
                    @chain ASR.sample(nm.model) ASR.intvec_to_sequence(_; alphabet)
                end
                write(writer, FASTA.Record(name, sequence))
            end
        end
    end
end

function parse_asr_state_file(file)
    dat = @chain begin
        CSV.File(file; comment="#")
        DataFrame
        groupby(_, :Node)
    end
    q = size(first(dat), 2) - 3 # number of cols

    alphabet = @chain first(dat) begin
        _[!, Not(:Node, :Site, :State)] # columns starting with p_LETTER
        names
        map(x -> x[3:end], _)
        prod
        ASR.Alphabet
    end
    # @info "File $file, alphabet $alphabet"

    map(pairs(dat)) do (node_gk, df)
        label = node_gk.Node
        # constructing profile model for node
        L = size(df, 1)
        P = [zeros(Float64, q) for _ in 1:L]
        for (i, row) in zip(df.Site, eachrow(df[!, Not([:Node, :Site, :State])]))
           P[i] = collect(values(row))
           @assert isapprox(sum(P[i]), 1, rtol = 1e-3)
           P[i] .= P[i]/sum(P[i])
        end

        ml_seq = prod(df.State)

        label => (ml_seq = ml_seq, model = ASR.ProfileModel(P; alphabet))
    end |> Dict
end
parse_iqtree_state_file(file; kwargs...) = parse_asr_state_file(file)

"""
    optimize_branch_length_iqtree(
        newick::AbstractString, aln::AbstractString, outnewick::AbstractString;
        model = nothing, iqtree_folder = "iqtree_branch_length/", iqtree_prefix = aln,
    )

Recompute branches using iqtree
- create folder `iqtree_folder` for iqtree temporary files (not removed)
- re-root output tree so that the splits are the same as in the original
- write output at `outnewick`
"""
function optimize_branch_length_iqtree(
    newick::AbstractString, aln::AbstractString, outnewick::AbstractString;
    model = nothing,
    iqtree_folder = joinpath(dirname(aln), "iqtree_branch_length/"),
    iqtree_prefix = basename(aln),
)
    # Figuring out root position from clades of the original tree
    tree = read_tree(newick)
    if length(children(tree.root)) != 2
        error("For now this function needs a root with exactly two children - got $(length(children(tree.root)))")
    end
    # info for rerooting correctly after
    root_splits = map(x -> map(label, POTleaves(x)), children(tree.root))
    root_branch_lengths = map(branch_length, children(tree.root))
    old_root_label = label(tree.root)

    # recomputing branch lengths
    total_prefix = joinpath(iqtree_folder, iqtree_prefix)
    mkpath(dirname(total_prefix))
    if isnothing(model)
        run(`iqtree2 -s $aln -te $newick -pre $(total_prefix) --keep-ident --redo`)
    else
        run(`iqtree2 -s $aln -te $newick -pre $(total_prefix) --keep-ident --redo -m $model`)
    end

    # re-rooting
    tree = read_tree(total_prefix * ".treefile")
    As = map(s -> lca(tree, s), root_splits)
    non_roots = findall(!isroot, As)
    if length(non_roots) > 1
        error("Should find root at least $(length(As)-1) times among previously root clades")
    elseif length(non_roots) == 1
        A = As[non_roots[1]]
        # we should root above A
        τ = root_branch_lengths[non_roots[1]] / sum(root_branch_lengths) * branch_length(A)
        TreeTools.root!(tree, label(A); time = τ)
        TreeTools.label!(tree, tree.root, old_root_label)
    end

    write(outnewick, tree)
    return tree
end
